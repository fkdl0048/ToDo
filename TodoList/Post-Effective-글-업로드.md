# Issue #830: Post: Effective 글 업로드

# Post: Effective 글 업로드

Effective C++ 각 아이템마다 포스팅 예정 이 이슈는 머리말에 해당하는 내용으로 책을 왜 읽는지 설명

- 면접과 언리얼 사용, 다른 엔진등의 지식에서 C++지식의 부족함을 느낌
- 각 아이템을 상사하게 작성하고 CodeReview, cpp-sandbox와 연계하여 지식의 깊이를 확장
- 추가로 북클럽과 연계하여 작성

## Comments

### Comment by fkdl0048 on 2024-09-10T05:22:54Z

작성 본문

---
title: "[Effective C++] Item 00: 읽기 시작하며"
excerpt: ""

categories:
  - Cpp
tags:
  - [Cpp, Dev]

toc: true
toc_sticky: true
 
date: 2024-09-10
last_modified_at: 2024-09-10
---

# [Effective C++] Item 00: 읽기 시작하며

이번에 호흡을 조금 길게 읽어볼 책은 Effective C++이다. 언리얼을 공부하며 필요성을 느끼기도 했지만, 최근 다른 엔진이나 게임 관련에 대해 발을 넓히다 보니 계속 보이는 내용은 결국은 C++이라는 것이다.

면접에서도 관련한 질문이 많이 들어왔다고 느끼고 진행중인 스터디에서도 신입 스터디원분들을 꼬시기 가장 좋은 책이라고 생각이 되어서 이번 [BookClub](https://github.com/BRIDGE-DEV/BRIDGE_BookClub)스터디를 통해 깊게 읽어볼 생각이다.

BookClub과 관련하여 책 읽기 스터디에 흥미가 있는 사람은 다음 링크를 통해 내용을 살펴보면 좋을 것 같다.

- [책읽기 스터디 그룹 BookClub 소개](https://fkdl0048.github.io/bookreview/Bookclub_promotion/)

책은 2주 간격으로 아이템 5개 정도씩 읽을 예정이며 아이템을 읽으며 생긴 의문이나 더 깊이가 필요한 내용들은 아래 CodeReview나 cpp-sandbox를 통해 구체화하고 정리할 예정이다.

- [CodeReview](https://github.com/fkdl0048/CodeReview)
  - Language링크에 cpp에 정리 중
- [cpp-sandbox](https://github.com/fkdl0048/cpp-sandbox)
  - 이 책은 읽기보다 실습의 형태를 가져가야 좋을 것 같아서 sandbox에서 구체화 예정

본격적으로 정리하기 이전의 머리말 내용이다.

## 머리말

3판이 나온 것에 대한 찬사와 좋은 책이라는 내용이 많이 있다.

### 작업 원칙 및 용어 대역

기본적인 작업 원칙에 대한 내용을 설명한다. (번역서이다 보니 영어에 대한 표현을 정리한다.)

- EC++: Effective C++
- MEC++: More Effective C++
- ESTL: Effective STL
- TC++PL: The C++ Programming Language

### 특정 용어에 대한 대역어

- implememtation: 구현환경
  - 표준안에서 제시하는 명세를 해석하고 만든 결과라는 뜻이며, 공급자의 중심의 의미를 다고 있다.
  - 프로그램 제작, 표준을 구현한 개발환경
- undefined: 미정의 사항, 정의되지 않은
  - 표준에서 undefined는 이식성이 없거나 잘못된 프로그램 구조 혹은 에러가 있는 데이터값이 불확실한 개체의 사용에 의존하는 동작
- implementation-defined: 구현별 정의 사항, 구현별 의존 사항, 구현에 따라 다른, 구현에 의존적인
  - 표준에서는 정확히 한 가지를 정하지 않고 여러가지 가능성을 제시하며, 구현에 따라 다르게 결정되는 사항
- public, protected, private: 그대로 사용

이외 책에서 사용하는 용어에 대한 번역은 **용어 대역표**를 참고한다.

### 독자 여러분 반갑습니다

- 프로그램을 효과적으로 돌아가게 하는 것은 별개의 관심사다.
  - 이런 능력을 키우고 학습하는 것이 중요
- C++는 효과적으로 구사하는 것은 어렵지 않다. 해당 책을 읽으면..
- 책에선 일반적인 설계 전략과 실전 세부사항을 다룬다.
- 이 책은 C++의 바이블은 아니지만 C++ 프로그래밍의 여러 방면을 다룬책으로 필요할 때 찾아보면 좋다. 일종의 지침이다.
- 안목을 기르자는 생각으로 이 책을 읽어라. 어떻게 동작하는지, 왜 이렇게 돌아가는지..!

*저자의 말처럼 필요할 때 찾아보면 좋을 것 같다. 이번 기회로 전체적으로 정리하며 읽어보고 나중에 필요할 때 더 깊게 읽어보면 좋을 것 같다.*

#### 용어 사용에 대하여

- **선언(declaration)**
  - '어떤 대상'의 이름과 타입을 컴파일러에게 알려 주는 것이다. 하지만 구체적인 세부사항은 들어 있지 않다.
  - 저자는 사용자 정의 타입의 변수만을 객체라고 한정하지 않는다. (빌트인 변수또한 객체라고 한다.)
  - C++은 C에서 그대로 내려오는 기호들 있기에 라이브러리가 겹칠 수 있다. 책에서는 대부분 `std`안에 있다고 생각해라
- **시그니처(signature)**
  - 모든 함수의 선언문에는 시그니처가 있다. 그 함수의 매개변수 리스트와 반환 타입이 나와 있다.
- **정의(definition)**
  - 선언에서 빠진 구체적인 세부사항을 컴파일러에게 제공하는 것이다.
  - 객체의 경우에 정의는 컴파일러가 그 객체에 대한 메모리를 마련해 놓는 부분이 된다.
  - 함수나 함수 템플릿에 대한 정의는 그들에 대한 본문을 제공한다.
  - 클래스 혹은 클래스 템플릿의 경우에는 그 클래스 혹은 템플릿의 멤버를 넣어 준 결과가 정의다.
- **초기화(initialization)**
  - 어떤 객체에 최초의 값을 부여하는 과정이다.
  - 사용자 정의 타입으로 객체를 생성한 경우, 초기화는 생성자에 의해 이루어진다.
- **기본 생성자(default constructor)**
  - 어떤 인자도 주어지지 않은 채로 호출될 수 있는 생성자이다.
  - 원래부터 매개변수가 없거나 모든 매개변수가 기본값을 가지고 있는 경우에는 기본 생성자가 될 수 있다. (선택적 매개변수)
- **복사 생성자(copy constructor)**
  - 어떤 객체의 초기화를 위해 그와 같은 타입의 객체로부터 초기화할 때 호출되는 함수
  - '값에 의한 전달(pass by value)'은 복사 생성자를 호출한다.
- **복사 대입 연산자(copy assignment operator)**
  - 같은 타입의 다른 객체에 어떤 객체의 값을 복사하는 용도로 쓰이는 함수이다.
  - `Widget w2(w1);`은 복사 생성자를 호출, `w2 = w1;`은 복사 대입 연산자를 호출한다. 하지만, `Widget w2 = w1;`은 복사 생성자를 호출한다.
- **STL: Standard Template Library**
  - C++의 표준 라이브러리에 속해 있는 라이브러리로 컨테이너, 알고리즘 및 이들과 관련된 기능들이 집결한 결정체
- **함수 객체(function object)**
  - 함수처럼 동작하는 C++ 객체가 STL에 상당수 포함되어 있다.
  - 함수 객체는 함수 호출 연산자인 `operator()`를 오버로드한 클래스로 만든다.
- **미정의 동작(undefined behavior)**
  - 정의되어 있지 않은 동작으로, 컴파일러나 런타임 시스템이 어떤 동작을 할지 알 수 없다.
  - 위험하고 예측할 수 없는 결과를 초래할 수 있다.
- **인터페이스(interface)**
  - C#과 다르게 C++은 인터페이스가 언어차원에서 주어지지 않는다.
  - 이 책에서 설명하는 '인터페이스'는 함수의 시그니처, 어떤 클래스가 접근 가능한 요소로 말한다.
- **사용자(client)**
  - 이 책에서 '사용자'는 내가 만든 코드를 사용하는 사람을 말한다.
  - 함수의 사용자는 그 함수를 사용하는 모든 대상이 해당된다. 그 함수를 호출하는 코드, 그런 코드를 작성했거나 유지보수하는 사람 모두가 사용자이다.

#### 이름짓기에 대한 규약

- 코드 주석문에서 생성자와 소멸자를 언급할 때는, 약자표기인 `ctor`와 `dtor`를 사용한다.
- 좌변과 우변을 축약하여 `LHS`와 `RHS`를 사용한다.
- 포인터의 이름을 지을 때는 타입 T의 객체에 대한 포인터 'pt'라고 부른다. T에 대한 포인터(pointer to T)

#### 스레딩에 대한 고려사항

**C++는 언어 차원에서 스레드에 대한 개념 자체가 없다.** 어떤 종류의 병행성도 고려하고 있지 않은 언어로 C++의 표준 라이브러리도 C++이 관여하고 있는 한, 다중스레드 프로그램이나 것은 존재하지 않는다.



---
title: "BookReview [GoodCode, BadCode]"
excerpt: " "

categories:
  - Bookreview
tags:
  - [Bookreview, Study]

toc: true
toc_sticky: true
 
date: 2023-01-05
last_modified_at: 2023-01-05
---

# GoodCode, BadCode  

> Good Code, Bad Code  
> 좋은 코드, 나쁜 코드(프로그래머의 코드 품질 개선법)  
> 톰 롱 지음 / 차건회 옮김  

## 📖 책을 고른 이유(동기)

멘토님께서 추천해주신 아카데미 컨퍼런스라는 독서모임에 들어가게 되면서 책 세권을 6개월 동안 격주로 읽고 토론할 수 있는 기회를 얻었다..!  

대부분 현직자분들이 많아서 많은 도움이 될테지만 반대로 '폐만 끼치지 말자'라는 생각 + '내가 뭔데'라는 생각..ㅋㅋ  

하지만 그럼에도 하고 싶은 이유는 앞 포스팅에서 말한 **성장하는 개발자**가 되기 위해 밸런스를 잡기 위한 발판이다.(습관으로 만들기 위해..)  

++ 매우 좋은 기회라는 것을 알기 때문에  

나름 어필한다면 아직 대학생이기 때문에 다른 시선이나 남들이 생각하지 못한 시선..?

## 머리말 

### 논의 사항  

> "협업은 다른 팀원과의 협력이기도 하지만, 미래의 나 혹은 과거의 나와의 협력입니다."

1. 항상 과거의 코드를 보게 되면 코드가 이해가 안가는 부분이 많습니다..! 다른 분들은 이러한 오류를 줄이는 방식이 궁금합니다.

### 책의 내용 및 정리

저자는 남들이 나의 코드를 수정해도 여전히 동작해야 한다고 말한다.  

최근에 과거에 푼 알고리즘 문제 풀이를 보게 되었는데 문제를 읽어도 코드가 이해가 되지 않았다..  

이유는 복잡한 문제에 인풋값을 알파벳 순서로 처리하고 주석 또한 존재하지 않아서 전혀 어떤 동작을 하는지 감이 안잡혔다.  

물론 코딩테스트에서는 위의 방법처럼 풀겠지만 혼자 풀이하는 과정에서는 좋은 방법은 아니였던 것 같다.  

기술의 습득에 있어서 매우 오랜시간이 걸린다고 한다.  

그때 그때 임시변통으로 자신이 저지른 실수에서 배우거나(반면교사..) 함께 일하는 선임자, 동료로 부터 단편적인 배움을 얻는다.  

좋은 코드를 한줄 쓰기 위해서 많은 경험들이 필요하다고 했을 때 이 책은 저자가 몇 십년간 배운 '좋은 코드'의 한 방법이다.  

위에서 방법이라고 생각한 이유는 저자가 계속 강조하는 **정답은 없다**이다.  

정답에 근접하기 위한 여러가지 방법은 존재하지만 인생도 그렇고 어디에나 정답은 없다고 생각한다.  

이 책은 그러한 방법 중 '좋은 코드'로 가기 위한 좋은 방법 중에 하나라고 생각한다.  

모든 예제가 의사코드로 되어 있고 열린 마인드..?로 하셨다고 하니.. 기대가 된다.

## 1장 코드의 품질

> 서두르지 않으면 더 빠르다.
### 논의 사항  

1. 10쪽에서 보여주는 극단적인 시나리오 A와 B이러한 절충점을 찾을 때는 프로젝트와 조직문화에 달려있다고 합니다.

실제로 경험을 해보셨는지와 과정과 결과가 궁금합니다..!  

논의사항을 작성해야 하는데 개인적인 궁금증을 적는 것 같습니다.. 

### 책의 내용 및 정리

핵심 주제  
* 코드 품질이 중요한 이유
* 고품질 코드가 이루고자 하는 네 가지 목표
* 고품질 코드 작성을 위한 높은 수준에서의 여섯가지 전략
* 고품질 코드 작성이 어떻게 중장기적으로 시간과 노력을 절약할 수 있는지

#### 좋은 소프트웨어와 끔찍한 소프트웨어  

생각해보니 사용하기 정말 불편했던 소프트웨어와 문제를 찾아볼 수 없고 편의성이 높았던 소프트웨어는 확연하게 구분된다.  

게임을 예로 들자면 내가 생각하기에 퀼리티나 편의성은 정말 사소한 디테일에서 나온다고 매번 생각한다.  

간단한 기능이라도 예외를 두고 만들었다면 해당 기능이 예외가 발생했을 때의 사용자는 불만도가 급격하게 상승하는 것 같다..  

반대로 있을 때의 기능도 마찬가지로 "이게 있어..?"  

이러한 차이의 기본이 여기서 말하는 확장성이 좋은 고품질의 코드가 아닐까..  

#### 소프트웨어가 만들어지는 과정 

1. 코드베이스(codebase): 소프트웨어를 빌드할 수 있는 코드가 저장된 저장소(git, perforce 등) Version Control System
2. 코드 제출(submitting code): 커밋, 풀리퀘라고 불리기도 한다. 로컬에 저장된 내용을 코드베이스에 제출을 의미
3. 코드 검토(code review): 제출전에 다른 동료들이 변경된 내용을 검토한다
4. 제출 전 검사(pre-submit check): 병합 전 훅, 병합 전 점검, 커밋 전 점검이라고 하기도 하며 테스트가 실패하거나 컴파일 오류 시 병합되지 않도록 관리한다.
5. 배포(release): 소프트웨어는 코드베이스의 스냅숏을 기반으로 빌드한다. 특정 버전을 가져와서 배포하는 프로세스를 **배포 브랜치 만들기(cutting release)**라고 한다.
6. 프로덕션(production): 소프트웨어가 서버나 시스템에 배포될 때, 테스트 환경과 같이 내부적으로 사용하는 것이 아닌 실제 서비스되는 환경을 가리킨다.  

#### 코드품질을 점검하는 방법  

코드 자체를 고품질 저품질로 정의하는 것 자체가 주관적인 행동이지만 이러한 주관을 좋은 방향으로 다듬기 위해선 다양한 경험이 필요하다.  

저자는 **코드**가 정말로 달성하려는 것이 무엇인지 생각해보는 것을 말한다.  

목표를 달성함에 있어서 도움이 되는 코드는 높은 품질의 코드이고, 방해가 된다면 낮은 품질의 코드이다.  

책에서는 코드라고 말했다면 몇일 전 멘토링을 받으며 객체지향에 대해서 이야기 했을 때 멘토님이 클래스의 이름과 public method만 나열해서 본다면 해당 객체의 목적을 알 수 있다고 해주셨다.  

마찬가지로 좋은 품질의 코드를 작성하기 위해선 목적과 존재의 이유가 명확해야 한다.

**코드 작성의 베이스 룰(상위 수준)**  

1. 작동해야 한다.
2. 작동이 멈춰서는 안 된다.
3. 변화하는 요구 사항에 적응해야 한다.  
4. 이미 존재하는 기능을 또다시 구현해서는 안된다.  

#### 코드 품질의 핵심 요소  

1. 코드는 읽기 쉬워야 한다.
2. 코드는 예측 가능해야 한다.
3. 코드는 오용하기 어렵게 만들라
4. 코드를 모듈화하라
5. 코드를 재사용 가능하고 일반화할 수 있게 작성하라
6. 테스트가 용이한 코드를 작성하고, 제대로 테스트하라

**재사용성과 일반화성의 차이**  

* 재사용성(reusability): 문제를 해결하기 위한 것이 여러가지 다른 상황에서도 사용될 수 있음을 의미
* 일반화성(generalizability): 개념은 유사하나 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미

드릴의 경우 구멍을 뚫는 다는 기능이 있어서 여러 곳에 적용할 수 있다.(재사용성)  
드릴이 앞에 파츠만 교체한다면 나서도 박을 때 사용이 가능하다.(일반화성)  

### 느낀점

머리말에서 말했던 정답은 없다 이후에 상당히 조심스러운게 느껴져서 재밌다.  

객체지향에 한정되긴 하지만 언어의 가능성을 열어두고 과 과학, 물리와 같은 법칙이 없음을 강조한다.  

스스로 절충점과 선을 찾아서 **선택과 집중..!**을 해야하는 점..!

예를 들어서 보여주는 상황들이 전부 재밌는 내용이라 집중이 잘되는 것 같다.. ~~초코 브라우니~~

모르는 내용이 많다보니 정리 내용도 길어지는 것 같습니다.  

조금씩 줄여보겠습니다..!  

++ "생각한다~" 문체를 줄이고 싶어서 "한다."로 제 생각을 썼는데 틀리거나 다른 말이 있을 수 있습니다.  

좋은 방향을 위해서 알려주세요!(절대 기분안나쁩니다 진짜로..)

## 2장 추상화 계층

> 코드 작성의 목적은 문제해결이다.

### 논의 사항

### 책의 내용 및 정리  

핵심 주제  
* 깔끔한 추상화 계층을 통해 문제를 하위 문제로 세분화하는 방법
* 추상화 계층이 코드 품질의 요소를 달성하는 데 어떻게 도움이 되는지
* API 및 구현 세부 사항
* 함수, 클래스 및 인터페이스를 사용해 코드를 추상화 계층으로 나누는 방법  

#### 문제의 단위  

상위 수준의 문제를 해결하기 위해선 여러개의 작은 하위 문제들이 필요하다.  

범용적인 내용인 것 같다.  

일을 처리함에 있어서 단위를 나누는게 마치 인터페이스로 세분화하여서 모듈화를 목적에 두는? 일상 생활도 마찬가지라는 생각이 든다.  

멘토링에서 처리해야 하는 일에 대해서 시간 단위로 일을 처리함을 물어보았는데 일에 단위를 시간으로 계산하기 보다 난이도로 결정하는게 좋을 것 같다고 하셨다.  

난이도를 [1 3 5 7]정도로 구분한다면 미리 쌓아둔 데이트를 기반으로 나누고 5, 7의 경우 다시 1 3 5정도로 세분화를 하는 것이다.  

하루 일에 대한 형태가 대충 트리형태로 그려지는 방법이였는데 매우 좋은 방법인것 같다.

그렇다고 해서 극단적인 세분화또한 독인 것 같다..(스스로 1 3 5 7에 대한 설계가 되어야함,, 0.2 0.1 이런 수준 x)  

#### 추상화 계층 구축의 장점  

1. 가독성: 코드베이스의 모든 세부사항을 이해하는 것은 불가능하지만 몇가지 높은 계층의 추상화를 이해하고 사용하는 것은 상당히 쉽다. 깨끗하고 뚜렷한 추상화 계층은 적은 개념을 다루기만 할 수 있다.  
2. 모듈화: 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 쉬워진다.
3. 재사용성 및 일반화: 하위 문제에 대한 간결한 추상화 계층으로 제시되면 하위 문제에 대한 재사용하기 쉬워진다. 그리고 문제가 적절한 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.
4. 테스트 용이성: 하위 문제에 대한 해결책이 견고한지 테스트를 해야하는데 코드가 추상화 계층으로 깨긋하게 분할되면 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 쉬워진다.  

// 10:28


### 느낀점  

## 3장 다른 개발자의 코드 계약

## 4장 오류


# 책의 내용(일부 줄거리)

- 인지혁명

읽는 중..

# 책을 읽고 느낀점

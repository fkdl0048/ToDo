---
title: "BookReview [GoodCode, BadCode]"
excerpt: " "

categories:
  - Bookreview
tags:
  - [Bookreview, Study]

toc: true
toc_sticky: true
 
date: 2023-01-05
last_modified_at: 2023-01-05
---

# GoodCode, BadCode  

> Good Code, Bad Code  
> 좋은 코드, 나쁜 코드(프로그래머의 코드 품질 개선법)  
> 톰 롱 지음 / 차건회 옮김  

## 📖 책을 고른 이유(동기)

멘토님께서 추천해주신 아카데미 컨퍼런스라는 독서모임에 들어가게 되면서 책 세권을 6개월 동안 격주로 읽고 토론할 수 있는 기회를 얻었다..!  

대부분 현직자분들이 많아서 많은 도움이 될테지만 반대로 '폐만 끼치지 말자'라는 생각 + '내가 뭔데'라는 생각..ㅋㅋ  

하지만 그럼에도 하고 싶은 이유는 앞 포스팅에서 말한 **성장하는 개발자**가 되기 위해 밸런스를 잡기 위한 발판이다.(습관으로 만들기 위해..)  

++ 매우 좋은 기회라는 것을 알기 때문에  

나름 어필한다면 아직 대학생이기 때문에 다른 시선이나 남들이 생각하지 못한 시선..?

## 머리말 

### 논의 사항  

> "협업은 다른 팀원과의 협력이기도 하지만, 미래의 나 혹은 과거의 나와의 협력입니다."

1. 항상 과거의 코드를 보게 되면 코드가 이해가 안가는 부분이 많습니다..! 다른 분들은 이러한 문제를 줄이는 방식이 궁금합니다.

### 책의 내용 및 정리

저자는 남들이 나의 코드를 수정해도 여전히 동작해야 한다고 말한다.  

최근에 과거에 푼 알고리즘 문제 풀이를 보게 되었는데 문제를 읽어도 코드가 이해가 되지 않았다..  

이유는 복잡한 문제에 인풋값을 알파벳 순서로 처리하고 주석 또한 존재하지 않아서 전혀 어떤 동작을 하는지 감이 안잡혔다.  

물론 코딩테스트에서는 위의 방법처럼 풀겠지만 혼자 풀이하는 과정에서는 좋은 방법은 아니였던 것 같다.  

기술의 습득에 있어서 매우 오랜시간이 걸린다고 한다.  

그때 그때 임시변통으로 자신이 저지른 실수에서 배우거나(반면교사..) 함께 일하는 선임자, 동료로 부터 단편적인 배움을 얻는다.  

좋은 코드를 한줄 쓰기 위해서 많은 경험들이 필요하다고 했을 때 이 책은 저자가 몇 십년간 배운 '좋은 코드'의 한 방법이다.  

위에서 방법이라고 생각한 이유는 저자가 계속 강조하는 **정답은 없다**이다.  

정답에 근접하기 위한 여러가지 방법은 존재하지만 인생도 그렇고 어디에나 정답은 없다고 생각한다.  

이 책은 그러한 방법 중 '좋은 코드'로 가기 위한 좋은 방향 중에 하나라고 생각한다.  

모든 예제가 의사코드로 되어 있고 열린 마인드..?로 하셨다고 하니.. 기대가 된다.

## 1장 코드의 품질

> 서두르지 않으면 더 빠르다.
### 논의 사항  

1. 10쪽에서 보여주는 극단적인 시나리오 A와 B이러한 절충점을 찾을 때는 프로젝트와 조직문화에 달려있다고 합니다.

이러한 극단적인 사례를 경험 해보셨는지 경험 해보셨다면 과정과 결과 그리고 회고가 궁금합니다.

### 책의 내용 및 정리

핵심 주제  
* 코드 품질이 중요한 이유
* 고품질 코드가 이루고자 하는 네 가지 목표
* 고품질 코드 작성을 위한 높은 수준에서의 여섯가지 전략
* 고품질 코드 작성이 어떻게 중장기적으로 시간과 노력을 절약할 수 있는지

#### 좋은 소프트웨어와 끔찍한 소프트웨어  

생각해보니 사용하기 정말 불편했던 소프트웨어와 문제를 찾아볼 수 없고 편의성이 높았던 소프트웨어는 확연하게 구분된다.  

게임을 예로 들자면 퀼리티나 편의성은 정말 사소한 디테일에서 나온다고 매번 생각한다.(게임에 한정되지 않지만)  

간단한 기능이라도 예외를 두고 만들었다면 해당 기능이 예외가 발생했을 때의 사용자는 불만도가 급격하게 상승하는 것 같다..  

반대로 편의적인 사소한 디테일을 경험할 때는 안정감을 느끼는 것 같다.

이러한 차이의 근본이 여기서 말하는 확장성이 좋은 고품질의 코드가 아닐까..  

#### 소프트웨어가 만들어지는 과정 

1. 코드베이스(codebase): 소프트웨어를 빌드할 수 있는 코드가 저장된 저장소(git, perforce 등) Version Control System
2. 코드 제출(submitting code): 커밋, 풀리퀘라고 불리기도 한다. 로컬에 저장된 내용을 코드베이스에 제출을 의미
3. 코드 검토(code review): 제출전에 다른 동료들이 변경된 내용을 검토한다
4. 제출 전 검사(pre-submit check): 병합 전 훅, 병합 전 점검, 커밋 전 점검이라고 하기도 하며 테스트가 실패하거나 컴파일 오류 시 병합되지 않도록 관리한다.
5. 배포(release): 소프트웨어는 코드베이스의 스냅숏을 기반으로 빌드한다. 특정 버전을 가져와서 배포하는 프로세스를 배포 브랜치 만들기(cutting release)라고 한다.
6. 프로덕션(production): 소프트웨어가 서버나 시스템에 배포될 때, 테스트 환경과 같이 내부적으로 사용하는 것이 아닌 실제 서비스되는 환경을 가리킨다.  

#### 코드품질을 점검하는 방법  

코드 자체를 고품질 저품질로 정의하는 것 자체가 주관적인 행동이지만 이러한 주관을 좋은 방향으로 다듬기 위해선 다양한 경험이 필요하다.  

저자는 **코드**가 정말로 달성하려는 것이 무엇인지 생각해보는 것을 말한다.  

목표를 달성함에 있어서 도움이 되는 코드는 높은 품질의 코드이고, 방해가 된다면 낮은 품질의 코드이다.  

며칠 전 멘토링을 받으며 객체지향에 대해서 이야기 했을 때 멘토님이 클래스의 이름과 public method만 나열해서 본다면 해당 객체의 목적을 알 수 있다고 해주셨다.  

마찬가지로 좋은 품질의 코드를 작성하기 위해선 목적과 존재의 이유가 명확해야 한다.

**코드 작성의 베이스 룰(상위 수준)**  

1. 작동해야 한다.
2. 작동이 멈춰서는 안 된다.
3. 변화하는 요구 사항에 적응해야 한다.  
4. 이미 존재하는 기능을 또다시 구현해서는 안된다.  

#### 코드 품질의 핵심 요소  

1. 코드는 읽기 쉬워야 한다.
2. 코드는 예측 가능해야 한다.
3. 코드는 오용하기 어렵게 만들라
4. 코드를 모듈화하라
5. 코드를 재사용 가능하고 일반화할 수 있게 작성하라
6. 테스트가 용이한 코드를 작성하고, 제대로 테스트하라

**재사용성과 일반화성의 차이**  

* 재사용성(reusability): 문제를 해결하기 위한 것이 여러가지 다른 상황에서도 사용될 수 있음을 의미
* 일반화성(generalizability): 개념은 유사하나 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미

드릴의 경우 구멍을 뚫는 다는 기능이 있어서 여러 곳에 적용할 수 있다.(재사용성)  
드릴이 앞에 파츠만 교체한다면 나서도 박을 때 사용이 가능하다.(일반화성)  

### 느낀점

머리말에서 말했던 정답은 없다 이후에 상당히 조심스러운게 느껴져서 재밌다.  

객체지향에 한정되긴 하지만 언어의 가능성을 열어두고 과학, 물리와 같은 법칙이 없음을 강조한다.  

스스로 절충점과 선을 찾아서 **선택과 집중**을 해야하는 점..!

예를 들어서 보여주는 상황들이 전부 재밌는 내용이라 집중이 잘되는 것 같다.. ~~초코 브라우니~~

## 2장 추상화 계층

> 코드 작성의 목적은 문제해결이다.

### 논의 사항

함수부분과 클래스부분을 읽으며 좀 더 극단적으로 가게된다면 함수형 프로그래밍으로 이어질 것 같다는 생각이 듭니다.  
명확한 차이점이 있겠지만 다른 분들이 느끼는 차이점이 궁금합니다.  
### 책의 내용 및 정리  

핵심 주제  
* 깔끔한 추상화 계층을 통해 문제를 하위 문제로 세분화하는 방법
* 추상화 계층이 코드 품질의 요소를 달성하는 데 어떻게 도움이 되는지
* API 및 구현 세부 사항
* 함수, 클래스 및 인터페이스를 사용해 코드를 추상화 계층으로 나누는 방법  

#### 문제의 단위  

상위 수준의 문제를 해결하기 위해선 여러개의 작은 하위 문제들이 필요하다.  

범용적인 내용인 것 같다.  

일을 처리함에 있어서 단위를 나누는게 마치 인터페이스로 세분화하여서 모듈화를 목적에 두는? 일상 생활도 마찬가지라는 생각이 든다.  

멘토링에서 처리해야 하는 일에 대해서 시간 단위로 일을 처리함을 물어보았는데 일에 단위를 시간으로 계산하기 보다 난이도로 결정하는게 좋을 것 같다고 하셨다.  

난이도를 [1 3 5 7]정도로 구분한다면 미리 쌓아둔 데이트를 기반으로 나누고 5, 7의 경우 다시 1 3 5정도로 세분화를 하는 것이다.  

하루 일에 대한 형태가 대충 트리형태로 그려지는 방법이였는데 매우 좋은 방법인것 같다.

그렇다고 해서 극단적인 세분화또한 독인 것 같다..(스스로 1 3 5 7에 대한 설계가 되어야함,, 0.2 0.1 이런 수준 x)  

#### 추상화 계층 구축의 장점  

1. 가독성: 코드베이스의 모든 세부사항을 이해하는 것은 불가능하지만 몇가지 높은 계층의 추상화를 이해하고 사용하는 것은 상당히 쉽다. 깨끗하고 뚜렷한 추상화 계층은 적은 개념을 다루기만 할 수 있다.  
2. 모듈화: 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 쉬워진다.
3. 재사용성 및 일반화: 하위 문제에 대한 간결한 추상화 계층으로 제시되면 하위 문제에 대한 재사용하기 쉬워진다. 그리고 문제가 적절한 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.
4. 테스트 용이성: 하위 문제에 대한 해결책이 견고한지 테스트를 해야하는데 코드가 추상화 계층으로 깨긋하게 분할되면 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 쉬워진다.  

계속 같은 목적을 이야기 하니까 슬슬 어느정도 청사진이 그려지는 것 같다.. 좋은 코드, 클린코드를 가지기 위해서 좀 더 생각해보고 지금까지 만든 코드를 반면교사로 삼아야겠다..
#### API(application programming interface)  

코드를 작성할 때 고려해야 하는 측면이 두가지가 있다.  

1. 코드를 호출할 때 볼 수 있는 내용
2. 코드를 호출할 때 볼 수 없는 내용

볼 수 있는 내용은 공개수준을 따라간다.  

* 퍼블릭 클래스, 인터페이스 및 메서드  
* 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 **개념**  
* 코드 호출 시 코드를 올바르게 사용하기 위해서 알아야 하는 정보  

반대로 볼 수 없는 내용은 **구현 세부 사항**이다.  

private아래 가려진 내부 함수와 변수들은 구현 세부 사항에 속하며 의존 하는 것 또한 세부 사항이다.  

++ public 메서드라고 해도 이름, 반환값, 인수, 문서를 제외한 함수 내부는 세부사항이다.  

#### 함수  

정말 객체지향에서 함수가 가져야 하는 기본적인 성격에 대해서 쉬운 기준을 보여주며 설명하지만 막상 내가 할 땐 왜이렇게 어려운지 모르겠다.  

지키겠다고 생각하지 않고 급하게 개발을 해서 결과물 위주의 코딩을 반복해서 그런 것 같다.  

읽기 좋은 함수를 짜고 확장성에 용이하고, 모듈화, 재사용성/일반화가 높은 수준의 함수를 요구한다.  

막상 그러한 함수를 짜더라도 어느정도 커플링이 존재하기 때문에 점점 거대해지는 것 같다..  

시간이 아주 조금 더 걸리더라도 헬퍼클래스로 빼거나 함수를 분리해야하는 정신이 필요하다.  

최종적으로는 글을 읽듯이 함수를 순차적으로 읽을 수 있게 되는게 현재로서는 가장 나에게 필요한 형태인듯 하다.

#### 클래스  

단일 클래스에 대한 크기는 정말 밭을 가는 행위인 것 같다.  

초장에 쉽게 갈려고 대충 갈고 농작물을 심어도 이후에 2배 3배로 고생하니 추상적 관계에 대해서 다시 고민하게 된다.  

위와 같은 과정을 이미 여러번 직면해보니 꼭 필요한 과정이라고 생각한다.  

왜 처음부터 구조를 생각해야 하는지 그 프로젝트를 보고 그 중간점을 찾는게 경험에서 나오는 능력인 것 같다.  

지금 진행중인 프로젝트를 열어보니 가장 긴줄이 700줄 정도가 되는 클래스라니..  

이걸 처음부터 수정을 할 생각을 해보기도 했지만 멘토님이 그 비용을 잘 생각해보고 이후에 좋은 반면교사로 활용해서 들고다니면 좋을 것이라는 이야기를 듣고 사이드 이펙트나 문제가 될만한 부분만 수정하고 그대로 두고 프로젝트를 마감할 생각이다..  

책에서 말하는 300줄의 경우 절대적인 지표가 될 수 없지만 경고의 역할이 좋아보인다.  

자신의 코드를 비판적으로 바라볼 때 줄수또한 좋은 지표가 되지 않을까.. (그렇다고 닌자코드나 줄 수를 줄이라는 노력이 아닌 것을 안다. 설계단계의 기준)  

> 한 클래스는 오직 한 가지 일에만 관심을 가져야 한다.  
> 클래스는 응집력이 있어야만 한다.  

위와 같이 `좋은 코드`를 위한 지표도 존재하지만 책에선 근본적인 핵심을 먼저 이행하길 권한다.  

1. 코드 가독성: 단일 클래스에 담겨 있는 개념이 많을수록 해당 클래스의 가독성은 저하된다. 인간은 기본적으로 멀티에 약하다. 자신도 이해하기 힘든 코드는 남들이 볼 땐 2~3배 읽기 힘들 것이라는 사실을 알아야 한다.  

사람들이 3줄요약을 좋아하는 이유도 비슷한 이유일 것.  

2. 코드 모듈화: 클래스 및 인터페이스의 사용은 코드 모듈화를 위한 좋은 방법 중 하나이다. 하위 문제에 대한 해결책이 하나의 클래스로 구현되어 있고, 다른 클래스와의 상호작용을 준비된 퍼블릭 메서드로만 이루어진다면 해결책에 대한 문제가 발생했을 때 쉽게 교체가 가능해진다. 말그대로 부품정도로..  

3. 코드 재사용성 및 일반화: 어떤 문제를 해결할 때 두 가지 하위 문제를 해결해야 하는 경우, 두가지 문제에 대한 해결책을 한 클래스로 묶어 둔다면 이후에 한가지 문제가 발생해도 다른 한가지 해결책을 사용할 기회가 줄어든다..  

4. 테스트 용이성 및 적절한 테스트: 마찬가지로 하위단위로 세분화가 된다면 테스트의 용이성으로 이어진다.  

#### 인터페이스  

인터페이스는 추상화 계층을 깔끔하게 구현하는 코드를 만드는데 있어 매우 유용한 도구이다.  

주어진 하위 문제에 대해 두가지 이상의 서로 다른 구헌이 가능해지고 이를 통해 모듈화를 실현할 수 있다.  

**하나의 인터페이스 및 단일 구현**  

인터페이스를 구현하는 클래스가 유일하다고 해도 이는 매우 유리하게 작용한다.  

**장점**

1. public API를 명확하게 보여준다.  

인터페이스를 상속받은 클래스가 인자로 사용하게 된다면 해당 클래스에 퍼블릭함수를 추가하더라도 상위 클래스는 인터페이스만을 의존하기 때문에 해당 퍼블릭함수는 노출이 되지 않는다.  

2. 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.  

원래 코드를 작성할 때는 또 다른 구현이 필요하지않을 것이라는 확신을 하더라도 한 두달 후엔 후회할 수 있다  

3. 테스트를 쉽게 할 수 있다.  

구현 클래스가 복잡하거나 네트워크 I/O에 의존하는 경우 목이나 페이크객체로 대체할 수 있다.  

4. 같은 클래스로 두 가지 하위 문제를 해결 할 수 있다.  

한 클래스가 두 개 이상의 서로 다른 추상화계층에 구현을 제공할 수 있다.  

장점이 있다면 단점도 물론이다.  

**단점**

1. 더 많은 작업이 필요하다.  

말 그대로 인터페이스를 정의할려면 코드를 더 작성해야 한다.(생각도 더 해야한다.)  

2. 코드가 복잡해질 수 있다.  

다른 개발자가 코드를 볼 때 하위 문제를 이해하기 위해선 클래스가 아닌 인터페이스 먼저 봐야한다.(해당 인터페이스를 구현하는 클래스를 봐야댐)  

> 인터페이스만을 위한 인터페이스를 작성해서는 안된다.  

이러한 단점도 존재하지만 장점도 명확하기 때문에 이 또한 절충점(선)을 잘 찾아야 할 것 같다.  

기본적인 스탠스로 클래스를 설계할 때 인터페이스를 붙이는 것이 어렵지 않게 설계해야 한다.  

> 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않은 경우에는 남용의 위협에도 불구하고 계층을 얇게 만드는 것이 좋다  

### 느낀점  

클래스를 많이 만드는 것에 대한 **무서움**을 줄여보자..(무작정 많이 만드는 것이 아닌 설계에 따라서)

과연 내가 많이 만드는 것에 대한 무서움을 느낀 것인지 그냥 귀찮아서 인지는 아직까지 잘 모르겠다.  

읽다보니 많이 부끄러워지기도 하고 개발을 1년하고 그만두는게 아니니까.. 문제점을 제대로 직면했다는 것이 중요하다.  

이번 챕터는 실제로 코드를 작성해보고 저자가 소개한 다양한 방법을 적용해보기 좋은 것 같다. 매우매우  

일단 기억나는대로 룰을 지켜가며 코딩한 뒤 다시 가독성, 모듈화, 재사용/일반화, 테스트 용이성을 토대로 비판적인 시각으로 바라보면 답이 쉽게 나올 것 같다.  

아직은 DI나 인터페이스자체를 상속, 인터페이스를 가지는 인터페이스등 다양하게 활용 경험이 없어서 조금 어려운 부분이 있다.  

내용을 정리해보며 공부하고 다시 포스팅 예정

개념은 잡힌 상태지만 활용아직 미숙..

## 3장 다른 개발자의 코드 계약

> 자신이 작성한 코드를 다른 개발자가 작업해야 하고 반대로 다른 개발자가 작업한 코드를 자신이 작업해야 한다.
### 논의 사항  

객체지향에 맞게 명확한 목적을 가진 클래스가 설계했다면 주석이 필요 없을까요?

하위단부터 추론이 가능한 1단계 이름부터 잘 설계되었다면 클래스를 거슬러 올라가는 불편함은 있겠지만 목적이 분명하다면 주석이 필요 없을 것 같다는 생각이 듭니다.  

### 책의 내용 및 정리

핵심 주제  

* 다른 개발자들이 코드와 어떻게 상호작용하는지
* 코드 계약과 코드 계약의 세부 조항
* 세부 조항을 최소화하는 것이 어떻게 오용과 예측을 벗어나는 코드를 예방하는 데 도움이 되는지  
* 세부 조항을 피할 수 없다면 체크와 어서션을 어떻게 사용할 수 있는가?  

#### 자신의 코드와 다른 개발자의 코드  

1장에서 설명한 `예측 가능한 코드를 작성하라`와 `코드를 오용하기 어렵게 만들어라` 이 두가지 원칙은 다른 사람과 상호작용할 때 일어날 수 있는 일이다.  

따라서 협업의 경우에는 아래 규칙을 고려하는 것이 좋다.  

1. 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.  
2. 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.  
3. 시간이 지남에 따라 자신의 코드를 기억하지 못한다.  

**자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.**  

자신의 로직에 너무 익숙해져 모든 것이 분명해 보이기 때문에 과정에 대해서 망각하게 된다.  

어느 시점부터는 다른 개발자가 작성한 코드와 상호작용하거나 변경할 수 있다는 점을 인지해야 한다.  

그렇다고 코드에 주석을 많이 달라는 것이 아닌 코드 자체를 읽기 쉽게 만들어야 한다.(본인이든 남이든)  

**다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.**  

내가 작성한 코드는 생각보다 많은 의존성을 가지게 될 것이다.  

또한 코드자체도 환경이나 요구사항으로 인해 많이 변화할 것이기 때문에 병합전에 이런 문제를 제대로 확인하고 넘어가야 한다.  

의도지 않게 문제가 발생하게 되면 찾기 쉽지 않기 때문에.. 

**시간이 지남에 따라 자신의 코드를 기억하지 못한다.**  

당장 저번달 작성한 코드도 기억안나고 읽히지도 않기 때문에..ㅜ  

#### 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?  

API 공개수준이외에도 내가 작성한 코드가 무슨 목적을 가지고 있는지 파악해야 한다.  

* 여러 가지 상황에서 어떤 함수를 호출해야 하는지  
* 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지  
* 어떤 값을 인수로 사용해야 하는지
* 코드가 수행하는 동작이 무엇인지
* 어떤 값을 반환하는지

> 1년이 지나면 자신이 작성한 코드라도 까먹기 때문에 미래의 자신은 본질적으로 다른 개발자라고 간주한다.  

따라서 다른 개발자가 내가 작성한 코드를 알아내기 위해선 다음과 같은 추리를 한다.  

1. 함수, 클래스, 열거형 등의 이름을 살펴본다.
2. 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다.
3. 함수/클래스 수준의 문서나 주석문을 읽어본다.
4. 직접 와서 묻거나 채팅/이메일을 통해 물어본다.
5. 여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽는다.  

이름 짓기의 경우 농담식으로 가장 오래걸리는 코딩작업이라고 한다.  

그만큼 다른 개발자(미래의 나)가 볼 때 직관성 띄기 때문에 바로바로 추론이 가능하다.  

멘토님의 말대로 클래스 이름과 퍼블릭 메서드만 나열해도 해당 클래스의 목적이 보여야 한다.  

#### 코드 계약  

계약에 의한 프로그래밍(programming by contract) 또는 계약에 의한 디자인(design by contract)라는 용어를 접해본적이 있을 것이다.  

~~나는 없다..~~  

이 방법론은 서로 다른 코드 간의 상호작용을 마치 계약처럼 생각한다는 점이다.  

계약은 3가지 범주로 나뉜다.  

* 선결 조건: 코드를 호출하기 전에 사실이어야 하는 것, 예를 들어 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지와 같은 사항  
* 사후 조건: 코드가 호출된 후에 사실이어야 하는 것, 예를 들어 시스템이 새로운 상태에 놓인다든지..  
* 불변 사항: 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항  

개발자가 계약의 일부 혹은 모든 조건을 알지 못하면 코드 계약에 문제가 발생한다.  

따라서 계약내용이 무엇일지, 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지에 대한 생각을 해야한다.  

코드를 오용할 수 있는 방법이 많을수록 실제로 오용되고 버그가 많이 있음을 시사한다.  

따라서 방어적인 프로그래밍 자세를 취하는게 좋아보인다.  

세부조항으로 문서나 주석을 통해 경고하는 것 보다 애초에 불가능하게 만드는 것이 좋다.  

내부적으로 예외를 많이 두어서 다른 방향으로 오용된다면 다른 개발자는 버그라고 생각  

*책에서는 생성자를 가려서 애초에 원하는 방법으로 객체를 생성하게 막아둠*  

#### 상태와 가변성  

객체지향에서 상태는 객체가 담고있는 어떤 값이나 데이터를 말한다. 이러한 상태를 생성 이후에 수정이 가능하다면 가변적, 반대로 수정이 불가능 하다면 불변적이라고 칭한다.  

### 느낀점

세부조항의 부분이 많이 생각하게 된다.  

이전에 기본 c라이브러리 함수를 구현한 적이 있는데 완벽한 함수를 만들겠다고 null에대한 예외처리 등 들어오는 값에 대한 예외를 되게 크게 잡았다.  

이후에 그게 틀렸다는 것만 알고 있었는데 이제와서 정리가 되는 것 같다.(의도하지 않은 동작, 오용)

지금 생각해보면 좋은 경험이였다.  

뒤쪽의 체크, 어서션은 읽어도 이해가 잘 되지 않아서 어려웠다..ㅠ  

## 4장 오류

> 코드가 실행되는 환경은 불완전하다.

### 논의 사항

실제로 예외를 구현해서 사용하는 경우가 많나요?  

대분의 예외는 만들어져있다고 알고 있었습니다.  

필요에 의해서 만들어진 예외는 어떤 경우가 있는지 궁금합니다.

### 책의 내용 및 정리

핵심 주제  

* 시스템이 복구할 수 있는 오류와 복구할 수 없는 오류의 구분
* 신속하게 실패하고 분명하게 실패함
* 오류를 전달하기 위한 다양한 기법과 선택을 위한 고려 사항  

#### 복구 가능성  

소프트웨어에 대해 생각할 때, 특정 오류가 발생한 경우 복구할 수 있는 오류와 복구할 수 없는 오류가 있다.  

즉, 오류가 발생했을 때 무엇을 할 것인지 결정하기 위해서는 자신의 코드가 어떻게 사용될 것인지 신중하게 생각해야한다.  

* 복구 가능한 오류  

전화번호를 예로 유효하지 않은 입력값이 들어왔을 때 전체시스템 작동을 멈춘다면 문제가 될 수 있다.  

따라서 오류메세지를 제공하고 다시 요청하는 것이 낫다.  

이 내용을 읽고 처음 든 생각은 하나의 함수 자체에서 널값이 들어왔을 때 `nullreferenceexception`이 발생하고 예외처리를 따로 하지 않았다면 시스템자체가 멈추게 된다.  

이러한 예외를 막고자 앞에서 말했던 방어적 프로그래밍으로 일어날 수 있는 예외를 사전에 미리 차단하는 것도 중요하다.  

그렇다면 여기서 또 의문이다. 3장에서 말했던 광범위한 함수 내부에서 예외처리를 하게 된다면 함수를 오용하게 되고 함수 자체의 성격도 옅어지게 된다.  

이러한 문제에서 절충점이 뭘까 생각하니 위에서 말한 함수내부에서 처리하지 않고 외부로 반환값을 줘서 해당 경우에 대한 예외레벨에서 처리하는 것이다.  

이게 맞는 방법인지는 잘모르겠지만.. 지금의 생각은 이렇다..  

* 복구할 수 없는 오류  

오류가 발생하고 시스템이 오류를 복구할 수 있는 합리적인 방법이 없을 때가 있다.  

대부분 프로그래밍 오류때문에 발생한다.  

* 코드와 함께 추가되어야 하는 리소스가 없다.
* 어떤 코드가 다른 코드를 잘못 사용한다.(잘못된 인수, 사전에 초기화 작업x)  

개발자가 이러한 오류를 해결하는 방법인 일찍이 오류를 발견하고 해결하는 것..  

> 신속한 실패  

#### 견고성과 실패  

소프트웨어가 오류가 발생한다면 실패와 견고성중 하나를 선택해야 한다.  

실패의 경우는 더 높은 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다.  

오류는 처리하고 계속 진행한다.  

후자의 경우는 실행자체에 문제가 없으니 견고한 코드라고 볼 수 있지만 위험부담을 그 만큼 가지고 갈 수 있다.  

**신속하게 실패하라**  

말 그대로 실패를 두려워 하지 않고 오류를 훌룡하고 안전하게 복구할 수 있는 기회라고 생각하는 것이다.  

이 또한 계층을 나누고 세분화를 통해 모듈화를 하게 되면 테스트에 용이하고 이 처럼 실패를 쉽게 만날 수 있다.  

**요란하게 실패하라**  

오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것이다.  

이를 위한 가장 명백한 방법은 예외를 발생해 프로그램이 중단되게 하는 것   

오류를 서버에 기록하는 방식의 내용이 나왔는데 가끔 프로그램에서 오류가 발생하면 해당 로그를 보내달라는 메세지같이 오류를 수집하는 내용도 흥미로웠다..  

#### 오류를 숨기지 않음  

오류를 숨겨서 프로그램의 동작이 문제가 없어 보여도 오류를 숨기는 것은 복구할 수 있는 오류와 복구할 수 없는 오류 두가지 문제를 모두 일으킨다.  

**기본값 반환**  

오류가 발생하고 함수가 값을 반환할 수 없을 때 기본값을 반환하는 것은 간단하고 쉬운 해결책처럼 보일 수 있다.  

이는 오류를 숨기는데 있어서 호출하는 쪽에서는 모든 것이 정상처럼 작동한다.  

당장 치명적인 오류를 가져올 수 있고 이후에 찾기 힘든 오류로 전락할 수 있다.  

**널 객체 패턴**  

개념적으론 기본값과 유사하지만 이것을 더 확장하여 더 복잡한 객체를 다룬다.  

널 객체는 실제 반환값처럼 보이지만 모든 멤버 함수는 아무것도 하지 않거나 의미 없는 기본값을 반환한다.  

**아무것도 하지 않음**  

코드가 무언가를 반환하지 않고 단지 어떤 작업을 수행하는 경우, 문제가 발생할 때 가능한 한 가지 옵션은 오류가 발생했다는 신호를 보내지 않는 것이다.  

#### 오류 전달 방법  

오류가 발생하면 일반적으로 더 높은 계층에게 알려야 한다.  

오류로부터 복구할 수 없는 경우 일반적으로 훨씬 높은 계층에서 실행을 중지하고 오류를 기록하거나 프로그램의 종료하는 것을 의미한다.  

* 명시적 방법: 코드를 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수 밖에 없도록 한다.  
* 암시적 방법: 코드를 호출하는 쪽에 오류를 알리지만, 호출하는 쪽에서 그 오류를 신경쓰지 않아도 된다.  

#### 예외  

예외라는 개념은 코드에서 오류나 예외적인 상황이 발생한 경우 이를 전달하기 위한 방법으로 고안되었다.  

일반적으로 예외 또한 충분한 기능을 가진 클래스로 구현되며, 요구사항에 맞춰 예외를 정의하고 구현할 수 있다.  

* 명시적 방법: 검사 예외  

컴파일러는 검사 예외에 대해 호출하는 쪽에서 예외를 인지하도록 강제적으로 조치하는데, 호출하는 쪽에서 예외 처리를 위한 코드를 작성하거나 자신의 함수 시그니처에 해당 예외 발생을 선언해야 한다.

*함수 시그니처란? 함수 원형에 명시되는 매개변수 리스트를 가리킨다.*  

* 암시적 방법: 비검사 예외  

비검사 예외를 사용하면 다른 개발자들은 코드가 이 예외를 발생시킬 수 있다는 사실을 전혀 모를 수 있다.  

이 경우에는 함수에서 어떤 예외를 발생시키는지 문서화를 하는 것이 바람직하지만 이 과정조차도 잊어버릴 때가 있다.  

하지만 이러한 문서화 작업은 앞서 다룬 세부조항이기 때문에 신뢰할 방법이 아니다.  

따라서 비검사 예외는 오류가 발생할 수 있다는 것을 호출하는 쪽에서 인지하리라는 보장이 없기 때문에 오류를 암시적으로 알리는 방법이다.  

* 명시적 방법: 널값이 가능한 반환 유형  

함수에서 널값을 반환하는 것은 특정값을 계산하거나 얻는 것이 불가능함을 나타내기 위한 효과적이고 간단한 방법이다.  

*https://learn.microsoft.com/ko-kr/training/modules/csharp-null-safety/*  

주로 사용하는 언어인 C#은 null 안정성에 대한 튜토리얼까지 만들어 두었다..(재밌다)  

현재로는 내가 가장 많이 예외를 처리하는 방법인 것 같다.  

내가 사용하는 처리방법에 대해 정리가 되고 다른 방법들도 소개가 되니 처음에는 읽기 힘들었는데 아는 내용과 상상가능한 내용이 나오니 다시 잘 읽어진다..  

* 명시적 방법: 리절트 반환 유형

널값이나 옵셔널 타입을 반환활 때의 문제 중 하나는 오류 정보를 전달할 수 없다는 것이다.  

호출자에게 값을 얻을 수 없음을 알릴 뿐만 아니라 값을 얻을 수 없는 이유까지 알려주면 유용하다.  

이러한 경우에는 리절트 유형을 사용하는 것이 적절할 수 있다.  

* 명시적 방법: 아웃컴 반환 유형  

어떤 함수들은 값을 반환하기보다는 단지 무언가를 수행하고 값을 변환하지 않는다.  

어떤일을 하는동안 오류가 발생해 그것을 호출한 쪽에 알리고자 한다면 함수가 수행한 동작의 결과를 나타내는 값을 반환하도록 함수를 수정하는 것이 한 가지 방법이 될 수 있다.  

* 암시적 방법: 프로미스 또는 퓨처  

비동기적으로 실행하는 코드를 작성할 때 프로미스나 퓨처를 반환하는 함수를 작성하는 것이 일반적이다.(대부분의 언어는 프로미스나 퓨처는 오류상태도 전달할 수 있다)  

* 암시적 방법: 매직값 반환  

매직값은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 부여하는 값이다.  

매직값이 반환될 수 있다는 사실을 알려면 문서나 코드를 읽어야 하기 때문에 암시적인 오류 전달 기법이다.  

#### 복구할 수 없는 오류의 전달  

앞서 말한 복구할 수 없는 오류가 발생한다면 신속하고 그리고 요란하게 실패하는 것이 최상의 방법이다.  

이를 달성하기 위한 몇가지 방법이 있다.  

* 비검사 예외를 발생  
* 프로그램이 패닉이 되도록
* 체크나 어셔선을 사용

이러한 경우 프로그램이 종료되는데, 이는 개발자들이 뭔가 잘못되었음을 알아차린다는 것을 의미한다.  

이러한 즉발적인 오류를 좋은 영향으로 인지하는게 중요하다.  

#### 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달  

이에 대한 방법은 다양하게 존재하며 상당히 주관적임을 설명한다.  

따라서 프로젝트 그리고 팀을 그대로 따라가는게 좋은 방법이다.  

#### 비 검사 예외 VS 명시적 기법  

* 비검사의 예외를 사용해야 한다는 주장

1. 코드 구조 개선: 대부분의 오류 처리 코드의 상위 계층에서 이루어질 수 있기 때문에 비검사 예외를 발생시켜 코드 구조의 개선을 주장
2. 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함

* 명시적 기법을 사용해야 한다는 주장  

1. 매끄러운 오류 처리: 비검사 예외를 사용한다면 모든 오류를 매끄럽게 처리할 수 있는 단일 계층을 갖기 어렵다.  
2. 실수로 오류를 무사할 수 없다: 어떤 호출자는 실제로 오류를 처리해야 하는 경우가 있을 수 있다.  
3. 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함(마찬가지로 적용 가능)  

다양한 주장이 있지만 저자는 `명시적 방식을 사용하라`라고 말한다.  

### 느낀점

경험이 부족하다 보니 단편적인 내용이나 상상으로 보는 부분이 있었다..  

나중에 경험을 하고 다시 읽어보면 또 크게 와닿지 않을까?  

읽다보니 오류를 예측하는 능력이 필요해보인다.  

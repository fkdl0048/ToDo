---
title: "BookReview [GoodCode, BadCode]"
excerpt: " "

categories:
  - Bookreview
tags:
  - [Bookreview, Study]

toc: true
toc_sticky: true
 
date: 2023-01-05
last_modified_at: 2023-01-05
---

# GoodCode, BadCode  

> Good Code, Bad Code  
> 좋은 코드, 나쁜 코드(프로그래머의 코드 품질 개선법)  
> 톰 롱 지음 / 차건회 옮김  

## 📖 책을 고른 이유(동기)

멘토님께서 추천해주신 아카데미 컨퍼런스라는 독서모임에 들어가게 되면서 책 세권을 6개월 동안 격주로 읽고 토론할 수 있는 기회를 얻었다..!  

대부분 현직자분들이 많아서 많은 도움이 될테지만 반대로 '폐만 끼치지 말자'라는 생각 + '내가 뭔데'라는 생각..ㅋㅋ  

하지만 그럼에도 하고 싶은 이유는 앞 포스팅에서 말한 **성장하는 개발자**가 되기 위해 밸런스를 잡기 위한 발판이다.(습관으로 만들기 위해..)  

++ 매우 좋은 기회라는 것을 알기 때문에  

나름 어필한다면 아직 대학생이기 때문에 다른 시선이나 남들이 생각하지 못한 시선..?

## 머리말 

### 논의 사항  

> "협업은 다른 팀원과의 협력이기도 하지만, 미래의 나 혹은 과거의 나와의 협력입니다."

1. 항상 과거의 코드를 보게 되면 코드가 이해가 안가는 부분이 많습니다..! 다른 분들은 이러한 오류를 줄이는 방식이 궁금합니다.

### 책의 내용 및 정리

저자는 남들이 나의 코드를 수정해도 여전히 동작해야 한다고 말한다.  

최근에 과거에 푼 알고리즘 문제 풀이를 보게 되었는데 문제를 읽어도 코드가 이해가 되지 않았다..  

이유는 복잡한 문제에 인풋값을 알파벳 순서로 처리하고 주석 또한 존재하지 않아서 전혀 어떤 동작을 하는지 감이 안잡혔다.  

물론 코딩테스트에서는 위의 방법처럼 풀겠지만 혼자 풀이하는 과정에서는 좋은 방법은 아니였던 것 같다.  

기술의 습득에 있어서 매우 오랜시간이 걸린다고 한다.  

그때 그때 임시변통으로 자신이 저지른 실수에서 배우거나(반면교사..) 함께 일하는 선임자, 동료로 부터 단편적인 배움을 얻는다.  

좋은 코드를 한줄 쓰기 위해서 많은 경험들이 필요하다고 했을 때 이 책은 저자가 몇 십년간 배운 '좋은 코드'의 한 방법이다.  

위에서 방법이라고 생각한 이유는 저자가 계속 강조하는 **정답은 없다**이다.  

정답에 근접하기 위한 여러가지 방법은 존재하지만 인생도 그렇고 어디에나 정답은 없다고 생각한다.  

이 책은 그러한 방법 중 '좋은 코드'로 가기 위한 좋은 방법 중에 하나라고 생각한다.  

모든 예제가 의사코드로 되어 있고 열린 마인드..?로 하셨다고 하니.. 기대가 된다.

## 1장 코드의 품질

> 서두르지 않으면 더 빠르다.
### 논의 사항  

1. 10쪽에서 보여주는 극단적인 시나리오 A와 B이러한 절충점을 찾을 때는 프로젝트와 조직문화에 달려있다고 합니다.

실제로 경험을 해보셨는지와 과정과 결과가 궁금합니다..!  

논의사항을 작성해야 하는데 개인적인 궁금증을 적는 것 같습니다.. 

### 책의 내용 및 정리

핵심 주제  
* 코드 품질이 중요한 이유
* 고품질 코드가 이루고자 하는 네 가지 목표
* 고품질 코드 작성을 위한 높은 수준에서의 여섯가지 전략
* 고품질 코드 작성이 어떻게 중장기적으로 시간과 노력을 절약할 수 있는지

#### 좋은 소프트웨어와 끔찍한 소프트웨어  

생각해보니 사용하기 정말 불편했던 소프트웨어와 문제를 찾아볼 수 없고 편의성이 높았던 소프트웨어는 확연하게 구분된다.  

게임을 예로 들자면 내가 생각하기에 퀼리티나 편의성은 정말 사소한 디테일에서 나온다고 매번 생각한다.  

간단한 기능이라도 예외를 두고 만들었다면 해당 기능이 예외가 발생했을 때의 사용자는 불만도가 급격하게 상승하는 것 같다..  

반대로 있을 때의 기능도 마찬가지로 "이게 있어..?"  

이러한 차이의 기본이 여기서 말하는 확장성이 좋은 고품질의 코드가 아닐까..  

#### 소프트웨어가 만들어지는 과정 

1. 코드베이스(codebase): 소프트웨어를 빌드할 수 있는 코드가 저장된 저장소(git, perforce 등) Version Control System
2. 코드 제출(submitting code): 커밋, 풀리퀘라고 불리기도 한다. 로컬에 저장된 내용을 코드베이스에 제출을 의미
3. 코드 검토(code review): 제출전에 다른 동료들이 변경된 내용을 검토한다
4. 제출 전 검사(pre-submit check): 병합 전 훅, 병합 전 점검, 커밋 전 점검이라고 하기도 하며 테스트가 실패하거나 컴파일 오류 시 병합되지 않도록 관리한다.
5. 배포(release): 소프트웨어는 코드베이스의 스냅숏을 기반으로 빌드한다. 특정 버전을 가져와서 배포하는 프로세스를 **배포 브랜치 만들기(cutting release)**라고 한다.
6. 프로덕션(production): 소프트웨어가 서버나 시스템에 배포될 때, 테스트 환경과 같이 내부적으로 사용하는 것이 아닌 실제 서비스되는 환경을 가리킨다.  

#### 코드품질을 점검하는 방법  

코드 자체를 고품질 저품질로 정의하는 것 자체가 주관적인 행동이지만 이러한 주관을 좋은 방향으로 다듬기 위해선 다양한 경험이 필요하다.  

저자는 **코드**가 정말로 달성하려는 것이 무엇인지 생각해보는 것을 말한다.  

목표를 달성함에 있어서 도움이 되는 코드는 높은 품질의 코드이고, 방해가 된다면 낮은 품질의 코드이다.  

책에서는 코드라고 말했다면 몇일 전 멘토링을 받으며 객체지향에 대해서 이야기 했을 때 멘토님이 클래스의 이름과 public method만 나열해서 본다면 해당 객체의 목적을 알 수 있다고 해주셨다.  

마찬가지로 좋은 품질의 코드를 작성하기 위해선 목적과 존재의 이유가 명확해야 한다.

**코드 작성의 베이스 룰(상위 수준)**  

1. 작동해야 한다.
2. 작동이 멈춰서는 안 된다.
3. 변화하는 요구 사항에 적응해야 한다.  
4. 이미 존재하는 기능을 또다시 구현해서는 안된다.  

#### 코드 품질의 핵심 요소  

1. 코드는 읽기 쉬워야 한다.
2. 코드는 예측 가능해야 한다.
3. 코드는 오용하기 어렵게 만들라
4. 코드를 모듈화하라
5. 코드를 재사용 가능하고 일반화할 수 있게 작성하라
6. 테스트가 용이한 코드를 작성하고, 제대로 테스트하라

**재사용성과 일반화성의 차이**  

* 재사용성(reusability): 문제를 해결하기 위한 것이 여러가지 다른 상황에서도 사용될 수 있음을 의미
* 일반화성(generalizability): 개념은 유사하나 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미

드릴의 경우 구멍을 뚫는 다는 기능이 있어서 여러 곳에 적용할 수 있다.(재사용성)  
드릴이 앞에 파츠만 교체한다면 나서도 박을 때 사용이 가능하다.(일반화성)  

### 느낀점

머리말에서 말했던 정답은 없다 이후에 상당히 조심스러운게 느껴져서 재밌다.  

객체지향에 한정되긴 하지만 언어의 가능성을 열어두고 과 과학, 물리와 같은 법칙이 없음을 강조한다.  

스스로 절충점과 선을 찾아서 **선택과 집중..!**을 해야하는 점..!

예를 들어서 보여주는 상황들이 전부 재밌는 내용이라 집중이 잘되는 것 같다.. ~~초코 브라우니~~

모르는 내용이 많다보니 정리 내용도 길어지는 것 같습니다.  

조금씩 줄여보겠습니다..!  

++ "생각한다~" 문체를 줄이고 싶어서 "한다."로 제 생각을 썼는데 틀리거나 다른 말이 있을 수 있습니다.  

좋은 방향을 위해서 알려주세요!(절대 기분안나쁩니다 진짜로..)

## 2장 추상화 계층

> 코드 작성의 목적은 문제해결이다.

### 논의 사항

함수부분과 클래스부분을 읽으며 좀 더 극단적으로 가게된다면 디커플링을 추구하는 형태라면 함수형 프로그래밍으로 이어질 것 같다는 생각이 듭니다.  
명확한 차이점이 있겠지만 다른 분들이 느끼는 차이점
### 책의 내용 및 정리  

핵심 주제  
* 깔끔한 추상화 계층을 통해 문제를 하위 문제로 세분화하는 방법
* 추상화 계층이 코드 품질의 요소를 달성하는 데 어떻게 도움이 되는지
* API 및 구현 세부 사항
* 함수, 클래스 및 인터페이스를 사용해 코드를 추상화 계층으로 나누는 방법  

#### 문제의 단위  

상위 수준의 문제를 해결하기 위해선 여러개의 작은 하위 문제들이 필요하다.  

범용적인 내용인 것 같다.  

일을 처리함에 있어서 단위를 나누는게 마치 인터페이스로 세분화하여서 모듈화를 목적에 두는? 일상 생활도 마찬가지라는 생각이 든다.  

멘토링에서 처리해야 하는 일에 대해서 시간 단위로 일을 처리함을 물어보았는데 일에 단위를 시간으로 계산하기 보다 난이도로 결정하는게 좋을 것 같다고 하셨다.  

난이도를 [1 3 5 7]정도로 구분한다면 미리 쌓아둔 데이트를 기반으로 나누고 5, 7의 경우 다시 1 3 5정도로 세분화를 하는 것이다.  

하루 일에 대한 형태가 대충 트리형태로 그려지는 방법이였는데 매우 좋은 방법인것 같다.

그렇다고 해서 극단적인 세분화또한 독인 것 같다..(스스로 1 3 5 7에 대한 설계가 되어야함,, 0.2 0.1 이런 수준 x)  

#### 추상화 계층 구축의 장점  

1. 가독성: 코드베이스의 모든 세부사항을 이해하는 것은 불가능하지만 몇가지 높은 계층의 추상화를 이해하고 사용하는 것은 상당히 쉽다. 깨끗하고 뚜렷한 추상화 계층은 적은 개념을 다루기만 할 수 있다.  
2. 모듈화: 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 쉬워진다.
3. 재사용성 및 일반화: 하위 문제에 대한 간결한 추상화 계층으로 제시되면 하위 문제에 대한 재사용하기 쉬워진다. 그리고 문제가 적절한 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.
4. 테스트 용이성: 하위 문제에 대한 해결책이 견고한지 테스트를 해야하는데 코드가 추상화 계층으로 깨긋하게 분할되면 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 쉬워진다.  

계속 같은 목적을 이야기 하니까 슬슬 어느정도 청사진이 그려지는 것 같다.. 좋은 코드, 클린코드를 가지기 위해서 좀 더 생각해보고 지금까지 만든 코드를 반면교사로 삼아야겠다..
#### API(application programming interface)  

코드를 작성할 때 고려해야 하는 측면이 두가지가 있다.  

1. 코드를 호출할 때 볼 수 있는 내용
2. 코드를 호출할 때 볼 수 없는 내용

볼 수 있는 내용은 공개수준을 따라간다.  

* 퍼블릭 클래스, 인터페이스 및 메서드  
* 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 **개념**  
* 코드 호출 시 코드를 올바르게 사용하기 위해서 알아야 하는 정보  

반대로 볼 수 없는 내용은 **구현 세부 사항**이다.  

private아래 가려진 내부 함수와 변수들은 구현 세부 사항에 속하며 의존 하는 것 또한 세부 사항이다.  

++ public 메서드라고 해도 이름, 반환값, 인수, 문서를 제외한 함수 내부는 세부사항이다.  

클래스의 관계에서 위와 같이 캡슐화를 위해 수준을 설정하는데 이를 API라고 부르는 것은 처음알았다..(어디서 듣거나 읽었을 테지만 까먹은 것 같다)  

#### 함수  

정말 객체지향에서 함수가 가져야 하는 기본적인 성격에 대해서 설명하지만 쉬운 기준을 보여주며 설명하지만 막상 내가 할 땐 왜이렇게 어려운지 모르겠다.  

지키겠다고 생각하지 않고 급하게 개발을 해서 결과물 위주의 코딩을 반복해서 그런 것 같다.  

읽기 좋은 함수를 짜고 확장성에 용이하고, 모듈화, 재사용성/일반화가 높은 수준의 함수를 요구한다.  

막상 그러한 함수를 짜더라도 어느정도 커플링이 존재하기 때문에 점점 거대해지는 것 같다..  

시간이 아주 조금 더 걸리더라도 헬퍼클래스로 빼거나 함수를 분리해야하는 정신이 필요하다.  

최종적으로는 글을 읽듯이 함수를 순차적으로 읽을 수 있게 되는게 현재로서는 가장 나에게 필요한 형태인듯 하다.

#### 클래스  

단일 클래스에 대한 크기는 정말 밭을 가는 행위인 것 같다.  

초장에 쉽게 갈려고 대충 갈고 농작물을 심어도 이후에 2배 3배로 고생하니 추상적 관계에 대해서 다시 고민하게 된다.  

위와 같은 과정을 이미 여러번 직면해보니 꼭 필요한 과정이라고 생각한다. 왜 처음부터 구조를 생각해야 하는지 그 프로젝트를 보고 그 중간점을 찾는게 경험에서 나오는 능력인 것 같다.  

지금 진행중인 프로젝트를 열어보니 가장 긴줄이 700줄 정도가 되는 클래스라니..  

이걸 처음부터 수정을 할 생각을 해보기도 했지만 멘토님이 그 비용을 잘 생각해보고 이후에 좋은 반면교사로 활용해서 들고다니면 좋을 것이라는 이야기를 듣고 사이드 이펙트나 문제가 될만한 부분만 수정하고 그대로 두고 프로젝트를 마감할 생각이다..  

책에서 말하는 300줄의 경우 절대적인 지표가 될 수 없지만 경고의 역할이 좋아보인다.  

자신의 코드를 비판적으로 바라볼 때 줄수또한 좋은 지표가 되지 않을까.. (그렇다고 닌자코드나 줄 수를 줄이라는 노력이 아닌 것을 안다. 설계단계의 기준)  

> 한 클래스는 오직 한 가지 일에만 관심을 가져야 한다.  
> 클래스는 응집력이 있어야만 한다.  

위와 같이 `좋은 코드`를 위한 지표도 존재하지만 책에선 근본적인 핵심을 먼저 이행하길 권한다.  

1. 코드 가독성: 단일 클래스에 담겨 있는 개념이 많을수록 해당 클래스의 가독성은 저하된다. 인간은 기본적으로 멀티에 약하다. 자신도 이해하기 힘든 코드는 남들이 볼 땐 2~3배 읽기 힘들 것이라는 사실을 알아야 한다.  

사람들이 3줄요약을 좋아하는 이유도 비슷한 이유일 것.  

2. 코드 모듈화: 클래스 및 인터페이스의 사용은 코드 모듈화를 위한 좋은 방법 중 하나이다. 하위 문제에 대한 해결책이 하나의 클래스로 구현되어 있고, 다른 클래스와의 상호작용을 준비된 퍼블릭 메서드로만 이루어진다면 해결책에 대한 문제가 발생했을 때 쉽게 교체가 가능해진다. 말그대로 부품정도로..  

3. 코드 재사용성 및 일반화: 어떤 문제를 해결할 때 두 가지 하위 문제를 해결해야 하는 경우, 두가지 문제에 대한 해결책을 한 클래스로 묶어 둔다면 이후에 한가지 문제가 발생해도 다른 한가지 해결책을 사용할 기회가 줄어든다..  

4. 테스트 용이성 및 적절한 테스트: 마찬가지로 하위단위로 세분화가 된다면 테스트의 용이성으로 이어진다.  

2.4 그림은 현재 내가 진행중인 프로젝트의 클래스를 많이 닮아있다..  

#### 인터페이스  

인터페이스는 추상화 계층을 깔끔하게 구현하는 코드를 만드는데 있어 매우 유용한 도구이다.  

주어진 하위 문제에 대해 두가지 이상의 서로 다른 구헌이 가능해지고 이를 통해 모듈화를 실현할 수 있다.  

**하나의 인터페이스 및 단일 구현**  

인터페이스를 구현하는 클래스가 유일하다고 해도 이는 매우 유리하게 작용한다.  

1. public API를 명확하게 보여준다.  

인터페이스를 상속받은 클래스가 인자로 사용하게 된다면 해당 클래스에 퍼블릭함수를 추가하더라도 상위 클래스는 인터페이스만을 의존하기 때문에 해당 퍼블릭함수는 노출이 되지 않는다.  

2. 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.  

원래 코드를 작성할 때는 또 다른 구현이 필요하지않을 것이라는 확신을 하더라도 한 두달 후엔 후회할 수 있다  

3. 테스트를 쉽게 할 수 있다.  

구현 클래스가 복잡하거나 네트워크 I/O에 의존하는 경우 목이나 페이크객체로 대체할 수 있다.  

4. 같은 클래스로 두 가지 하위 문제를 해결 할 수 있다.  

한 클래스가 두 개 이상의 서로 다른 추상화계층에 구현을 제공할 수 있다.  

장점이 있다면 단점도 물론이다.  

1. 더 많은 작업이 필요하다.  

말 그대로 인터페이스를 정의할려면 코드를 더 작성해야 한다.(생각도 더 해야한다.)  

2. 코드가 복잡해질 수 있다.  

다른 개발자가 코드를 볼 때 하위 문제를 이해하기 위해선 클래스가 아닌 인터페이스 먼저 봐야한다.(해당 인터페이스를 구현하는 클래스를 봐야댐)  

> 인터페이스만을 위한 인터페이스를 작성해서는 안된다.  

이러한 단점도 존재하지만 장점도 명확하기 때문에 이 또한 절충점(선)을 잘 찾아야 할 것 같다.  

기본적인 스탠스로 클래스를 설계할 때 인터페이스를 붙이는 것이 어렵지 않게 설계해야 한다.  

> 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않은 경우에는 남용의 위협에도 불구하고 계층을 얇게 만드는 것이 좋다  

### 느낀점  

클래스를 많이 만드는 것에 대한 **무서움**을 줄여보자..(무작정 많이 만드는 것이 아닌 설계에 따라서)  

읽다보니 많이 부끄러워지기도 하고 개발을 1년하고 그만두는게 아니니까.. 문제점을 제대로 직면했다는 것이 중요하다  

이번 챕터는 실제로 코드를 작성해보고 저자가 소개한 다양한 방법을 적용해보기 좋은 것 같다. 매우매우  

일단 기억나는대로 룰을 지켜가며 코딩한 뒤 다시 가독성, 모듈화, 재사용/일반화, 테스트 용이성을 토대로 비판적인 시각으로 바라보면 답이 쉽게 나올 것 같다.  

아직은 DI나 인터페이스자체를 상속, 인터페이스를 가지는 인터페이스등 다양하게 활용 경험이 없어서 조금 어려운 부분이 있다.  

내용을 정리해보며 공부하고 다시 포스팅 예정

개념은 잡힌 상태지만 활용아직 미숙..

## 3장 다른 개발자의 코드 계약

> 자신이 작성한 코드를 다른 개발자가 작업해야 하고 반대로 다른 개발자가 작업한 코드를 자신이 작업해야 한다.
### 논의 사항  

논의를 해야하지만 경험이 없어서 질문만 올리는 것 같습니다..ㅠ  

객체지향에 맞게 명확한 목적을 가진 클래스가 설계했다면 주석이 필요 없을까요?

하위단부터 추론이 가능한 1단계 이름부터 잘 설계되었다면 클래스를 거슬러 올라가는 불편함은 있겠지만 목적이 분명하다면 주석이 필요 없을 것 같다는 생각이 듭니다.  

### 책의 내용 및 정리

핵심 주제  

* 다른 개발자들이 코드와 어떻게 상호작용하는지
* 코드 계약과 코드 계약의 세부 조항
* 세부 조항을 최소화하는 것이 어떻게 오용과 예측을 벗어나는 코드를 예방하는 데 도움이 되는지  
* 세부 조항을 피할 수 없다면 체크와 어서션을 어떻게 사용할 수 있는가?  

#### 자신의 코드와 다른 개발자의 코드  

1장에서 설명한 `예측 가능한 코드를 작성하라`와 `코드를 오용하기 어렵게 만들어라` 이 두가지 원칙은 다른 사람과 상호작용할 때 일어날 수 있는 일이다.  

따라서 협업의 경우에는 아래 규칙을 고려하는 것이 좋다.  

1. 저산에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.  
2. 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.  
3. 시간이 지남에 따라 자신의 코드를 기억하지 못한다.  

**저산에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.**  

자신의 로직에 너무 익숙해져 모든 것이 분명해 보이기 때문에 과정에 대해서 망각하게 된다.  

어느 시점부터는 다른 개발자가 작성한 코드와 상호작용하거나 변경할 수 있다는 점을 인지해야 한다.  

그렇다고 코드에 주석을 많이 달라는 것이 아닌 코드 자체를 읽기 쉽게 만들어야 한다.(본인이든 남이든)  

**다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.**  

내가 작성한 코드는 생각보다 많은 의존성을 가지게 될 것이다.  

또한 코드자체도 환경이나 요구사항으로 인해 많이 변화할 것이기 때문에 병합전에 이런 문제를 제대로 확인하고 넘어가야 한다.  

의도지 않게 문제가 발생하게 되면 찾기 쉽지 않기 때문에.. 

**시간이 지남에 따라 자신의 코드를 기억하지 못한다.**  

당장 저번달 작성한 코드도 기억안나고 읽히지도 않기 때문에..ㅜ  

#### 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?  

API 공개수준이외에도 내가 작성한 코드가 무슨 목적을 가지고 있는지 파악해야 한다.  

* 여러 가지 상황에서 어떤 함수를 호출해야 하는지  
* 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지  
* 어떤 값을 인수로 사용해야 하는지
* 코드가 수행하는 동작이 무엇인지
* 어떤 값을 반환하는지

> 1년이 지나면 자신이 작성한 코드라도 까먹기 때문에 미래의 자신은 본질적으로 다른 개발자라고 간주한다.  

따라서 다른 개발자가 내가 작성한 코드를 알아내기 위해선 다음과 같은 추리를 한다.  

1. 함수, 클래스, 열거형 등의 이름을 살펴본다.
2. 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다.
3. 함수/클래스 수준의 문서나 주석문을 읽어본다.
4. 직접 와서 묻거나 채팅/이메일을 통해 물어본다.
5. 여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽는다.  

이름 짓기의 경우 농담식으로 가장 오래걸리는 코딩작업이라고 한다.  

그만큼 다른 개발자(미래의 나)가 볼 때 직관성 띄기 때문에 바로바로 추론이 가능하다.  

멘토님의 말대로 클래스 이름과 퍼블릭 메서드만 나열해도 해당 클래스의 목적이 보여야 한다.  

#### 코드 계약  

계약에 의한 프로그래밍(programming by contract) 또는 계약에 의한 디자인(design by contract)라는 용어를 접해본적이 있을 것이다.  

~~나는 없다..~~  

이 방법론은 서로 다른 코드 간의 상호작용을 마치 계약처럼 생각한다는 점이다.  

계약은 3가지 범주로 나뉜다.  

* 선결 조건: 코드를 호출하기 전에 사실이어야 하는 것, 예를 들어 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지와 같은 사항  
* 사후 조건: 코드가 호출된 후에 사실이어야 하는 것, 예를 들어 시스템이 새로운 상태에 놓인다든지..  
* 불변 사항: 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항  

개발자가 계약의 일부 혹은 모든 조건을 알지 못하면 코드 계약에 문제가 발생한다.  

따라서 계약내용이 무엇일지, 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지에 대한 생각을 해야한다.  

코드를 오용할 수 있는 방법이 많을수록 실제로 오용되고 버그가 많이 있음을 시사한다.  

따라서 방어적인 프로그래밍 자세를 취하는게 좋아보인다.  

세부조항으로 문서나 주석을 통해 경고하는 것 보다 애초에 불가능하게 만드는 것이 좋다.  

내부적으로 예외를 많이 두어서 다른 방향으로 오용된다면 다른 개발자는 버그라고 생각  

*책에서는 생성자를 가려서 애초에 원하는 방법으로 객체를 생성하게 막아둠*  

#### 상태와 가변성  

객체지향에서 상태는 객체가 담고있는 어떤 값이나 데이터를 말한다. 이러한 상태를 생성 이후에 수정이 가능하다면 가변적, 반대로 수정이 불가능 하다면 불변적이라고 칭한다.  

### 느낀점

세부조항의 부분이 많이 생각하게 된다.  

이전에 기본 c라이브러리 함수를 구현한 적이 있는데 완벽한 함수를 만들겠다고 null에대한 예외처리 등 들어오는 값에 대한 예외를 되게 크게 잡았다.  

이후에 그게 틀렸다는 것만 알고 있었는데 이제와서 정리가 되는 것 같다.  

지금 생각해보면 좋은 경험이였다.  

뒤쪽의 체크, 어서션은 읽어도 이해가 잘 되지 않아서 어려웠다..ㅠ  

## 4장 오류

> 코드가 실행돠는 환경은 불완전하다.

### 논희 사항


### 책의 내용 및 정리

핵심 주제  

* 시스템이 복구할 수 있는 오류와 복구할 수 없는 오류의 구분
* 신속하게 실패하고 분명하게 실패함
* 오류를 전달하기 위한 다양한 기법과 선택을 위한 고려 사항  

#### 복구 가능성  

소프트웨어에 대해 생각할 때, 특정 오류가 발생한 경우 복구할 수 있는 오류와 복구할 수 없는 오류가 있다.  

즉, 오류가 발생했을 때 무엇을 할 것인지 결정하기 위해서는 자신의 코드가 어떻게 사용될 것인지 신중하게 생각해야한다.  

* 복구 가능한 오류  



오류를 예측하는 능력이 필요

### 느낀점

# 책의 내용(일부 줄거리)

- 인지혁명

읽는 중..

# 책을 읽고 느낀점
